<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈HashMap</title>
      <link href="/2019/07/17/qian-tan-hashmap/"/>
      <url>/2019/07/17/qian-tan-hashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是HashMap"><a href="#一-什么是HashMap" class="headerlink" title="一. 什么是HashMap"></a>一. 什么是HashMap</h2><blockquote><p>简单来说HashMap时基于哈希值，计算索引值进行存取数据的Map集合。底层利用了数组，链表，红黑树结构。该类继承了<code>AbstractMap&lt;K,V&gt;</code>,实现了<code>Map&lt;K,V&gt;</code>，<code>Cloneable</code>，<code>Serializable</code>接口，其实<br><code>AbstractMap&lt;K,V&gt;</code>已经实现了<code>Map&lt;K,V&gt;</code>接口，其实目的就是在使用者声明变量时可以去使用Map接受HashMap，<code>Cloneable</code>，<code>Serializable</code>一个克隆，一个序列化接口就不多做解释了。</p></blockquote><h2 id="二-HashMap源码分析"><a href="#二-HashMap源码分析" class="headerlink" title="二. HashMap源码分析"></a>二. HashMap源码分析</h2><h3 id="1-HashMap中的常量，变量"><a href="#1-HashMap中的常量，变量" class="headerlink" title="1.HashMap中的常量，变量"></a>1.HashMap中的常量，变量</h3><blockquote><p>这里只讨论HashMap中的，不记录从父类继承的</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认初始容量16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//HashMap最大容量2的30次方</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认的扩容因子</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//转为红黑树的阈（ps：yu总念错）值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span>；<span class="token comment" spellcheck="true">//转为链状结构阈值</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最小树形化容量阈值（防止桶内元素太多时，则直接扩容，而不是树形化）</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//transient是为了序列化时不序列化该属性，Node是HashMap的一个静态内部类，在java1.8版本中改为Node，之前为Entry对象，个人认为是因为引入LinkedHashMap，将LinkedHashMap的节点值定为了Entry避免冲突而更换名字。该属性是HashMap的主体，被称为表。</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含所有entry对象的集合，通过entrySet（）可获取该值，在遍历HashMap时会用到该对象</span><span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//map的大小，即当前有多少个Node</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;上面所写的是需要理解的一些属性值，在使用HashMap时也会经常使用到。</p><p><img src="/img/20190717/HashMap%E5%9B%BE.jpg" alt></p><p>&emsp;&emsp;从上图也能更好的理解表（table），桶（bucket），树之间的关系。</p><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h3><blockquote><p>HashMap的构造方法有四种</p></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//给定初始容量，扩容因子</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//HashMap的容量必须为2的次幂，所以调用了tableSizeFor（）方法转为整数大且最接近的2次幂数</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用上一个构造函数</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用默认值</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//用已有Map对象创建HashMap</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//放入对应的值，false参数与LinkedHashMap有关</span>        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//调整初始化容量方法</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Node静态内部类"><a href="#3-Node静态内部类" class="headerlink" title="3.Node静态内部类"></a>3.Node静态内部类</h3><blockquote><p>Node是HashMap中最基本的对象</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Node是单向链表，它实现了Map.Entry接口</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造函数 Hash值 键 值 下一个节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token operator">=</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4.get方法"></a>4.get方法</h3><blockquote><p>面向使用者的get方法实际是调用了getNode（）方法</p></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将该key的hash值计算出来，与key传入方法</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义局部变量</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对table进行判断该map是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token comment" spellcheck="true">//找到key值对应下标</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//从第一个元素寻找是不是该元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果是TreeNode在树中查找</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//在链表中查找</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//都不满足返回null</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5.put方法"></a>5.put方法</h3><blockquote><p>面向使用者的put方法实际是调用了putVal（）方法</p></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤①：tab为空则创建 </span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤②：计算index，并对null做处理  </span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤③：节点key存在，直接覆盖value </span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤④：判断该链为红黑树 </span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤⑤：该链为链表 </span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤⑥：超过最大容量 就扩容 </span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个方法我感觉是HashMap逻辑上最重要的实现方法很多方法都是围绕着它进行展开，在看该图时应对应下图</p></blockquote><p><img src="/img/20190717/put.jpg" alt="putVal方法"></p><h3 id="6-resize方法"><a href="#6-resize方法" class="headerlink" title="6.resize方法"></a>6.resize方法</h3><blockquote><p>该方法是在table初始化或者扩容时调用该方法</p></blockquote><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 保存当前table</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存当前table的容量</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存当前阈值</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化新的table容量和阈值 </span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*        1. resize（）函数在size　> threshold时被调用。oldCap大于 0 代表原来的 table 表非空，           oldCap 为原表的大小，oldThr（threshold） 为 oldCap × load_factor        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若旧table容量已超过最大容量，更新阈值为Integer.MAX_VALUE（最大整形值），这样以后就不会自动扩容了。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">// 容量翻倍，使用左移，效率更高</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 阈值翻倍</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*        2. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 大于0，代表用户创建了一个 HashMap，但是使用的构造函数为                 HashMap(int initialCapacity, float loadFactor) 或 HashMap(int initialCapacity)           或 HashMap(Map&lt;? extends K, ? extends V> m)，导致 oldTab 为 null，oldCap 为0， oldThr 为用户指定的 HashMap的初始容量。    　　*/</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>            <span class="token comment" spellcheck="true">//当table没初始化时，threshold持有初始容量。还记得threshold = tableSizeFor(t)么;</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*        3. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 等于0，用户调用 HashMap()构造函数创建的　HashMap，所有值均采用默认值，oldTab（Table）表为空，oldCap为0，oldThr等于0，        */</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 新阈值为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 初始化table</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 把 oldTab 中的节点　reHash 到　newTab 中去</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 若节点是单个节点，直接在 newTab　中进行重定位</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 若节点是　TreeNode 节点，要进行 红黑树的 rehash　操作</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 若是链表，进行链表的 rehash　操作</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割（代码后有图解，可以回过头再来看），分成两个不同的链表，完成rehash</span>                        <span class="token keyword">do</span> <span class="token punctuation">{</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 根据算法　e.hash &amp; oldCap 判断节点位置rehash　后是否发生改变</span>                            <span class="token comment" spellcheck="true">//最高位==0，这是索引不变的链表。</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                 <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">//最高位==1 （这是索引发生改变的链表）</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                  <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 原bucket位置的尾指针不为空(即还有node)  </span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 链表最后得有个null</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 链表头指针放在新桶的相同下标(j)处</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// rehash　后节点新的位置一定为原来基础上加上　oldCap，具体解释看下图</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此方法在调用时会引发一个问题，怎么扩容效率最高？在下一部分对此作出解释。这个方法解释参考<a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">一文读懂HashMap</a></p></blockquote><h2 id="三-HashMap中运算优化"><a href="#三-HashMap中运算优化" class="headerlink" title="三.HashMap中运算优化"></a>三.HashMap中运算优化</h2><h3 id="1-HashMap中Hash值的计算方法"><a href="#1-HashMap中Hash值的计算方法" class="headerlink" title="1.HashMap中Hash值的计算方法"></a>1.HashMap中Hash值的计算方法</h3><blockquote><p>HashMap是根据hashcode（）计算索引值的，在不重写hashcode（）方法时，不同对象的hashcode（）是不同的。如果我们重写了equal（）方法，让两个对象逻辑上相等，我们必须重写hashcode（）方法，否则两个对象equal（）相等，但是他们hashcode（）不同，所计算的下标值也不同。所以无法通过equal（）相同的key找到该val；</p></blockquote><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;现在我们说说计算hash值的方法，HashMap中通过获取key对象的hashCode()，先无符号右移16位，再与自己做异或运算，该方式是为了让高位与地位充分参与运算，已达到散列的效果。</p><ul><li><p>例如  </p><p>  原 来 的 hashCode : 1111 1111 1111 1111 0100 1100 0000 1010<br>  移位后的hashCode:   0000 0000 0000 0000 1111 1111 1111 1111<br>  进行异或运算 结果：  1111 1111 1111 1111 1011 0011 1111 0101</p></li></ul><p>&emsp;&emsp;最后通过与table长度减一进行与运算，计算出索引下标（即（n-1）&amp; hash ，hash%2<sup>n</sup> 等价于 hash&amp;(2<sup>n</sup>-1),<strong>位运算只能用于除数是2的n次方的数的求余</strong>,位运算的效率要高于取余，所以在java1.8中对该方法进行了优化）。</p><h3 id="2-HashMap中扩容计算方法"><a href="#2-HashMap中扩容计算方法" class="headerlink" title="2.HashMap中扩容计算方法"></a>2.HashMap中扩容计算方法</h3><blockquote><p>这里贴出resize方法的部分代码对应下面所提出的两种情况</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 原bucket位置的尾指针不为空(即还有node)  </span>    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 链表最后得有个null</span>    newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 链表头指针放在新桶的相同下标(j)处</span> <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// rehash　后节点新的位置一定为原来基础上加上　oldCap，具体解释看下图</span>    newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里要说明的就是HashMap使用2的n次幂做容量的部分原因了，我们知道索引是（2<sup>n</sup>-1），所以用二进制可以表示为1，11，111，111，1111，….等等。索引是与32为的二进制hash值进行与运算。如下图</p><p><img src="/img/20190717/%E6%89%A9%E5%AE%B9%E8%AE%A1%E7%AE%97.png" alt="扩容计算"></p><p>&emsp;&emsp;从图可看出扩容后一共只有两种变化元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。<br>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。这样对应上图就好理解多了。</p><h2 id="四-hashMap与HashTable的区别"><a href="#四-hashMap与HashTable的区别" class="headerlink" title="四. hashMap与HashTable的区别"></a>四. hashMap与HashTable的区别</h2><blockquote><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p></blockquote><ol><li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li><li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li><li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。  </li></ol><p>取自<a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">一文读懂HashMap</a></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><blockquote><p>以上是我这几天对HashMap的总结结合了多篇文章以及自我理解，欢迎大家相互讨论学习，如有错误请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA编程 </tag>
            
            <tag> HashMap </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot单例对象注入多例对象</title>
      <link href="/2019/07/13/springboot-dan-li-zhu-ru-duo-li/"/>
      <url>/2019/07/13/springboot-dan-li-zhu-ru-duo-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习redis集群，从最开始的安装，配置，到shards（分片）机制，sentinel(哨兵)机制，到最后的cluster（集群）机制。在测试哨兵机制的时候，踩了一个坑，经过一天的排查最后确定了问题，解决了问题，作为一个小白还是蛮开心的。话不说多直接上问题。</p></blockquote><p><img src="/img/20190713/p1.png" alt="异常"></p><p>&emsp;&emsp;首先先介绍下业务场景，在搭建好一主两从的redis哨兵模式后，启动了tomcat服务器，访问业务以及缓存服务，未发生任何异常，但是在我宕掉主机后从机生效，在后台查看redis主从信息没有任何问题，但是前台再次访问业务时，并无数据显示，并在tomcat服务器控制台中输出了，该异常<code>redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream.</code>，从异常上看是redis运行时抛出的，并且异常信息中拿不到什么有用的信息，因为初次接触redis，最开始我一直在找redis的配置与逻辑上的问题，测试好久没得到结论，上网查了好久也尝试了很多网上的办法，可惜都没有生效。<br>&emsp;&emsp;经过一下午测试，后来发现之前写的测试类可以正常访问我的redis服务器，最终把问题锁定在了业务代码逻辑上。</p><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// 该类写在service层</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Jedis jedis<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是我的业务逻辑代码，该方法主要是从数据库查询类目表</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>EasyUI_Tree<span class="token operator">></span> <span class="token function">findItemCatByCache</span><span class="token punctuation">(</span>Long parentId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义一个List接收返回数据</span>        List<span class="token operator">&lt;</span>EasyUI_Tree<span class="token operator">></span> itemCats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义redis key值</span>        String key <span class="token operator">=</span> <span class="token string">"ITEM_CAT_"</span> <span class="token operator">+</span> parentId<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从redis中读取值</span>        String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出hash值</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>jedis<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断结果是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//为空查询数据库，并赋值</span>            itemCats <span class="token operator">=</span> <span class="token function">findItemCatByParentId</span><span class="token punctuation">(</span>parentId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将缓存存入reids</span>            jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> JsonUtil<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span>itemCats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不为空直接处理json结果转为对象，并赋值</span>            itemCats <span class="token operator">=</span> JsonUtil<span class="token punctuation">.</span><span class="token function">toObject</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回该值</span>        <span class="token keyword">return</span> itemCats<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;该代码从表面看起来没有什么问题，这也是我这次踩坑的原因，其中sevice层在spring容器中是单例的，而jedis是一个多例对象，问题来了，spring的bean对象是在容器初始化时创建的其中service对象是单例的，导致在建立sercive对象时，已经为创建一个jedis对象并进行了DI（依赖注入），所以在我们进行我们的业务逻辑时，一直使用的是同一个对象，我对该方法jedis的hash值进行了输出，该对象hash相同（hash相同并不完全能证明他们是同一对象，如果大佬有更好的比较方式请指教），所以最后抛出了上述异常，下面看看解决方案。</p><blockquote><p>其实原因知道了，解决方案就好办了，下面贴出代码进行参考</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemCatServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ItemCatService</span><span class="token punctuation">,</span>BeanFactoryAware <span class="token punctuation">{</span>    <span class="token keyword">private</span> BeanFactory factory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ItemCatMapper itemCatMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>EasyUI_Tree<span class="token operator">></span> <span class="token function">findItemCatByCache</span><span class="token punctuation">(</span>Long parentId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>EasyUI_Tree<span class="token operator">></span> itemCats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//给定redis中key值</span>        String key <span class="token operator">=</span> <span class="token string">"ITEM_CAT_"</span> <span class="token operator">+</span> parentId<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从spring工厂中获取jedis对象</span>        Jedis jedis <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"jedis"</span><span class="token punctuation">,</span>Jedis<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>jedis<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String result <span class="token operator">=</span> jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            itemCats <span class="token operator">=</span> <span class="token function">findItemCatByParentId</span><span class="token punctuation">(</span>parentId<span class="token punctuation">)</span><span class="token punctuation">;</span>            jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> JsonUtil<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span>itemCats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            itemCats <span class="token operator">=</span> JsonUtil<span class="token punctuation">.</span><span class="token function">toObject</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> itemCats<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//继承BeanFactoryAware接口重写</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span>BeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>factory<span class="token operator">=</span> beanFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;从上面代码能看出这次我们每次执行是从spring容器中动态获取的bean对象，所以每次得到的都是不同的bean对象。<br>&emsp;&emsp;其实redis的哨兵模式在实际应用中使用的并不多，但是Spring中单例对象注入多例对象是很常见的。这次踩坑，也让自己以后能注意到这个问题，以此记录。</p><blockquote><p>文章仅供参考，如有不正确的地方或者不同意见请联系我并指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 踩坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA编程 </tag>
            
            <tag> Spring </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMWare的连接方式</title>
      <link href="/2019/07/12/vmware-de-san-chong-lian-jie-fang-shi/"/>
      <url>/2019/07/12/vmware-de-san-chong-lian-jie-fang-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>VMWare是一款桌面虚拟化的产品,作为程序猿来说常用作在学习linux(为了学习linux,买一台服务器可是太浪费了).最早在没接触编程,之前就使用过.当时是为了玩一款游戏,自己在虚拟机搭建服务器,将网游作为单机玩.跟着教程也是一步步搭建起来了,但是现在想想也为当初的不求甚解,付出了代价</p></blockquote><blockquote><p>接下来介绍一下它们分别是：</p><ol><li>Bridged（桥接模式）</li><li>NAT（网络地址转换模式）</li><li>Host-Only（仅主机模式）</li></ol></blockquote><hr><h2 id="一-VMWare三种网络连接方式"><a href="#一-VMWare三种网络连接方式" class="headerlink" title="一.VMWare三种网络连接方式"></a>一.VMWare三种网络连接方式</h2><blockquote><p>首先打开虚拟网络编辑器我们可以看见三个模式分别是VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式),其中在VMnet1、VMnet8物理主机会为他们分配两块虚拟网卡</p></blockquote><p><img src="/img/vmware/host1.png" alt></p><p><img src="/img/vmware/host2.png" alt></p><h3 id="1-Bridged桥接模式"><a href="#1-Bridged桥接模式" class="headerlink" title="1.Bridged桥接模式"></a>1.Bridged桥接模式</h3><blockquote><p>桥接模式就是使用物理主机网卡与虚拟机的虚拟网卡搭建网桥进行网路通信,类似于将物理主机作为交换机,这种方式完全可以将虚拟机当作网络中另一台”物理主机”  </p></blockquote><blockquote><p>桥接模式需要物理主机与虚拟机处于同一网段,并且网关,与DNS与主机保持一致,这时虚拟主机即可实现上网功能,在该模式下,会占用局域网ip资源,并且网络中其他主机,与该物理主机相同,都具有访问该虚拟机的权限,所以该模式不安全</p></blockquote><p><img src="/img/vmware/host3.png" alt="Bridged桥接模式"></p><h3 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h3><blockquote><p>NAT : Network Address Translation，网络地址转换<br>NAT是一种比较安全的连接方式,它所有访问网络的数据都是由主机提供的,类似于该主机与主机中的虚拟机处于同一局域网下,所以一般从外界主机是访问不到该虚拟主机的,虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。<br>VMnet8的作用是实现主机与虚拟机互相通信，可以通过禁用VMnet8网卡测试虚拟机与外网和本机的连接状态，测试结果为VMnet8网卡不影响虚拟机连接 Internet，但是与主机连接失败</p></blockquote><p><img src="/img/vmware/host4.png" alt="NAT模式"></p><p><img src="/img/vmware/NAT8.png" alt="NAT模式测试"></p><p><img src="/img/vmware/NAT9.png" alt="NAT模式测试"></p><h3 id="3-Host-Only（仅主机模式）"><a href="#3-Host-Only（仅主机模式）" class="headerlink" title="3.Host-Only（仅主机模式）"></a>3.Host-Only（仅主机模式）</h3><blockquote><p>该模式就是NAT模式去除了NAT网卡，使虚拟机只能和主机通信，不能与Internet通信。这种模式使用最少，至少我到现在没有使用过，该模式使用的是VMnet1网卡，如果想了解更多自行百度吧，我这里就不介绍过多了。</p></blockquote><h2 id="二-NAT模式的虚拟转发"><a href="#二-NAT模式的虚拟转发" class="headerlink" title="二.NAT模式的虚拟转发"></a>二.NAT模式的虚拟转发</h2><blockquote><p>前两天想用自己的笔记本连到同网络台式的虚拟机中,因为某些原因，我台式与虚拟机使用NAT方式连接，当时也不太明白三种连接方式的区别，无意义的捣鼓一上午没什么进展，后来发现了端口转发功能，但是按照步骤一部部设置完了，结果还是连接不上，排查好久才发现上午把NAT模式的默认IP更改了，虚拟机广播的是196字段，我连接的是176字段，导致台式主机找不到虚拟机的IP，所以就去研究了下三种连接方式的区别。以此记录，下面我介绍下NAT模式的虚拟转发</p></blockquote><blockquote><p>正常情况下NAT的连接模式是不允许外部计算机访问内部的虚拟计算机的，但是可以使用VMWare的端口转发功能来实现该功能，原理就是外部主机请求物理主机某一个端口，物理主机接到该端口的请求转发虚拟机对应的某个端口，实现起来相对也比较简单</p></blockquote><p><img src="/img/vmware/NAT1.png" alt="NAT模式端口转发"></p><p><img src="/img/vmware/NAT2.jpg" alt="NAT模式端口转发"></p><blockquote><p>下图是在学习时使用了端口转发具体流程图</p></blockquote><p><img src="/img/vmware/all.png" alt="流程图"></p><hr><blockquote><p>以上就是我对VMWare的连接方式简单理解，如果有错误的地方希望大家多多指正（来自一个小白的真心求教），谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 踩坑实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMWare </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2019/07/08/markdown-yu-fa/"/>
      <url>/2019/07/08/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h2 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h2><blockquote><p>用1-6个#代表html中<code>&lt;h1&gt;-&lt;h6&gt;</code>标题样式,该主题中对标题样式有修改</p></blockquote><p><strong>代码示例</strong></p><pre><code>    # 标题1                     ## 标题2                   ### 标题3                #### 标题4                  ##### 标题5    ###### 标题6               </code></pre><h2 id="二-段落"><a href="#二-段落" class="headerlink" title="二.段落"></a>二.段落</h2><blockquote><p>段落不需要特殊的标志，以两个空格加上回车表示换行  </p></blockquote><p> 段落一<br> 段落二（没加空格）<br> 段落三（加空格） </p><p><strong>代码示例</strong></p><pre><code>    段落一    段落二（没加空格）      段落三（加空格）</code></pre><h2 id="三-字体"><a href="#三-字体" class="headerlink" title="三.字体"></a>三.字体</h2><blockquote><p>markdown中带有默认的字体样式，但改变颜色，字体，大小,位置等需要自己写html代码标签</p></blockquote><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><font size="5" color="red" face="楷体"><strong><em>粗斜体文本</em></strong>  </font></p><p><strong>代码示例</strong></p><pre><code>    *斜体文本*    _斜体文本_    **粗体文本**    __粗体文本__    ***粗斜体文本***    &lt;font size=6 color=red face=&quot;楷体&quot;&gt;___粗斜体文本___  &lt;/font&gt;</code></pre><h2 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h2><blockquote><p>可以用至少三个个星号，减号等建立一个分割线，个人感觉还是很人性化的</p></blockquote><hr><p><strong>代码示例</strong></p><pre><code>    -----------    **************</code></pre><h2 id="五-删除线，下划线"><a href="#五-删除线，下划线" class="headerlink" title="五.删除线，下划线"></a>五.删除线，下划线</h2><blockquote><p>删除线在文字上添加中划线，也就是删除线在文字前后添加两个~~即可<br>下划线是通过html<code>&lt;u&gt;</code>标签来实现的  </p></blockquote><p><del>删除线</del><br><u>下划线</u>  </p><p><strong>代码示例</strong></p><pre><code>    ~~删除线~~      &lt;u&gt;下划线&lt;/u&gt; </code></pre><h2 id="六-脚注"><a href="#六-脚注" class="headerlink" title="六.脚注"></a>六.脚注</h2><blockquote><p>脚注就是对文本补充说明具体样式如下(PS:我的编辑器不支持T_T)</p></blockquote><p>&nbsp;正文<a href="脚注内容">^3</a>文字  </p><p><strong>代码示例</strong></p><pre><code>    正文[^3]文字      [^3]: 脚注内容</code></pre><h2 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h2><blockquote><p>列表分为有序列表与无序列表，有序列表使用 数字.加空格 例 <code>1.</code>实现，无序列表可以使用<code>*</code>,<code>+</code>,<code>-</code>作为标记实现，列表嵌套时在父列表下添加缩进</p></blockquote><p>无序列表  </p><ul><li>第一项</li><li>第二项</li><li>第三项  </li></ul><ul><li>第一项</li><li>第二项</li><li>第三项  </li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表</p><ol><li>第一项<ul><li>嵌套无序列表一</li><li>嵌套无序列表二</li></ul></li><li>第二项<ul><li>嵌套无序列表一</li><li>嵌套无序列表二</li></ul></li><li>第三项<ul><li>嵌套无序列表一</li><li>嵌套无序列表二</li></ul></li></ol><p><strong>代码示例</strong></p><pre><code>    无序列表      * 第一项    * 第二项    * 第三项      - 第一项    - 第二项    - 第三项      + 第一项    + 第二项    + 第三项    有序列表    1. 第一项        - 嵌套无序列表一        - 嵌套无序列表二    2. 第二项        - 嵌套无序列表一        - 嵌套无序列表二    3. 第三项        - 嵌套无序列表一        - 嵌套无序列表二</code></pre><h2 id="八-区块"><a href="#八-区块" class="headerlink" title="八.区块"></a>八.区块</h2><blockquote><p>区块是在段落开头使用<code>&gt;</code>加空格符号使用</p></blockquote><p>简单引用</p><blockquote><p>区块引用<br>区块引用<br>区块引用  </p></blockquote><p>嵌套引用</p><blockquote><p>区块1</p><blockquote><p>区块2</p><blockquote><p>区块3</p></blockquote></blockquote></blockquote><p>区块列表</p><blockquote><p>区块引用</p><ul><li>第一个</li><li>第二个</li></ul><ol><li>第一个</li><li>第二个</li></ol></blockquote><p>列表区块  </p><ol><li>第一条<blockquote><p>区块引用</p></blockquote></li><li>第二条<blockquote><p>区块引用</p></blockquote></li></ol><p><strong>代码示例</strong></p><pre><code>    简单引用    &gt; 区块引用      &gt; 区块引用      &gt; 区块引用      嵌套引用    &gt; 区块1    &gt;&gt; 区块2    &gt;&gt;&gt; 区块3    区块列表    &gt; 区块引用    &gt; - 第一个    &gt; - 第二个    &gt; 1. 第一个    &gt; 2. 第二个    列表区块      1. 第一条        &gt; 区块引用    2. 第二条        &gt; 区块引用</code></pre><h2 id="九-代码"><a href="#九-代码" class="headerlink" title="九.代码"></a>九.代码</h2><blockquote><p>如果单个代码片段可以使用 ` 反引号把它包起来，代码区块使用4个空格，即一个制表符（Tab），或者一对 ``` 标签将代码包起来并可以指定语言</p></blockquote><p>代码片段<br><code>System.out.print(&quot;hello world&quot;)</code>  </p><p>代码区块  </p><pre><code>public static void main(String[] args){    System.out.print(&quot;hello world&quot;);}</code></pre><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>代码示例</strong></p><pre><code>    代码片段      `System.out.print(&quot;hello world&quot;)`      代码区块          public static void main(String[] args){            System.out.print(&quot;hello world&quot;);        }    ```java    public static void main(String[] args){            System.out.print(&quot;hello world&quot;);        }    ```</code></pre><h2 id="十-链接"><a href="#十-链接" class="headerlink" title="十.链接"></a>十.链接</h2><blockquote><p>超链接使用[连接名称](连接地址)或者&lt;连接地址&gt;来实现html中<code>&lt;a&gt;&lt;/a&gt;</code>标签的使用<br>可以结合变量附带连接类似于脚注</p></blockquote><p>这是一个连接<a href="http://www.fbxblog.xyz" target="_blank" rel="noopener">我的博客</a></p><p><a href="http://www.fbxblog.xyz" target="_blank" rel="noopener">http://www.fbxblog.xyz</a></p><p>这个是变量1的连接<a href="http://google.com/" title="Google" target="_blank" rel="noopener">1</a><br>这个是变量2的连接<a href="http://baidu.com/" title="Baidu" target="_blank" rel="noopener">2</a></p><p><strong>代码示例</strong>  </p><pre><code>    这是一个连接[我的博客](http://www.fbxblog.xyz)    &lt;http://www.fbxblog.xyz&gt;    这个是变量1的连接[google]    这个是变量2的连接[baidu]  [google]: http://google.com/        &quot;Google&quot;   [baidu]: http://baidu.com/         &quot;Baidu&quot;</code></pre><h2 id="十一-图片"><a href="#十一-图片" class="headerlink" title="十一.图片"></a>十一.图片</h2><blockquote><p>图片格式为<code>![alt 属性文本](图片地址 &quot;标题&quot;)</code>,属性文本位置为图片加载失败时显示内容,”标题”为鼠标接触时的提示信息</p></blockquote><p><img src="https://www.baidu.com/img/bd_logo1.png" alt title="百度搜索"></p><blockquote><p>也可用变量来表示地址值</p></blockquote><p><img src="https://www.baidu.com/img/bd_logo1.png" alt title="百度搜索"></p><blockquote><p>如果想要指定宽高就使用<code>&lt;img&gt;</code>标签吧</p></blockquote><img src="https://www.baidu.com/img/bd_logo1.png" width="50%" height="50%" title="百度搜索"><p><strong>代码示例</strong></p><pre><code>![](https://www.baidu.com/img/bd_logo1.png &quot;百度搜索&quot;)![][addr][addr]:https://www.baidu.com/img/bd_logo1.png &quot;百度搜索&quot;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;百度搜索&quot;&gt;</code></pre><h2 id="十二-表格"><a href="#十二-表格" class="headerlink" title="十二.表格"></a>十二.表格</h2><blockquote><p>表格的语法使用 <code>|</code> 来创建一个一个的单元格使用 <code>-</code> 来将表头展现出来,使用 <code>:</code> 符号来对该列的对齐方式, <code>:</code> 所在侧即为向哪侧对齐</p></blockquote><table><thead><tr><th align="left">表头1</th><th align="right">表头2</th><th align="center">表头3</th></tr></thead><tbody><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr><tr><td align="left">左对齐</td><td align="right">右对齐</td><td align="center">居中</td></tr></tbody></table><p><strong>代码示例</strong></p><pre><code>    表头1|表头2|表头3    :-|-:|:-:    左对齐|右对齐|居中    左对齐|右对齐|居中    左对齐|右对齐|居中    左对齐|右对齐|居中    左对齐|右对齐|居中</code></pre><h2 id="十三-其他"><a href="#十三-其他" class="headerlink" title="十三.其他"></a>十三.其他</h2><blockquote><p>如果Markdown不满足需求的话可以使用原生的HTML代码去直接书写所需内容<br>书写特殊字符需要转义使用 <code>\</code> 来进行转义</p></blockquote><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p><strong>代码示例</strong></p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><blockquote><p>以上所有总结参考了<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>Markdown的教程,文章仅作为本人学习记录使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSLi的开场白</title>
      <link href="/2019/07/08/ssli-de-kai-chang-bai/"/>
      <url>/2019/07/08/ssli-de-kai-chang-bai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个码农，天天接近15，6个小时坐在电脑前，与互联网打交道，我感觉应该在互联网找个安身之处。<br>&nbsp;&nbsp;&nbsp;&nbsp;在我写这篇文章时，它一无所有。也希望今后我会好好的善待它。  </p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;本博客为静态博客，也主要是为了我总结学习历程，踩坑实录，游戏经历等(最为一个游戏爱好者的操守)。以及督促以及养成总结，归纳的能力，最重要还有写文章的能力(正在博文写的我现在终于体会到了什么是书到用时方恨少)。  </p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;声明:该博客完全搬用hexo博客框架，以及制作主题的大佬。作为后端工程师，前端没太多时间去研究(虽然现在后端我也是小白中的小白)，在这里诚挚感谢。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人记事 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
